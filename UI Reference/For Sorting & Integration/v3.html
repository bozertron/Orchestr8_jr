

The error `metaThemeColorTag is null` combined with the "Z.ai" logs tells me exactly what's happening: **Z.ai's environment does not support modern ES Modules (`type="module"`) when you paste code into it.**

It tries to load my "Import Map," and the internal system crashes or conflicts with the page's own initialization scripts.

**The Fix:** We need to switch from "Modern Modules" to **"Universal (UMD)"** scripts. These are the old-school way of loading libraries, but they work in *any* browser environment, including chat windows, without CORS issues.

Here is the **Universal Version** of the Crystal City.

**Instructions:**
1.  Copy this entire block.
2.  Paste it into a **new file** (e.g., `city.html`) on your computer and open it in Chrome/Edge (Best performance).
3.  **OR**, paste it directly into the Z.ai chat window. (It should now work, though performance might be lower than a native file).

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crystal City: Universal</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI OVERLAY - HUD STYLE */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to 3D */
            display: flex; flex-direction: column; justify-content: space-between;
            z-index: 10;
        }

        /* TOP BAR - THE "TV" FRAME */
        #hud-top {
            padding: 20px 40px; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            color: rgba(255,255,255,0.8);
            text-transform: uppercase; letter-spacing: 3px;
            font-size: 12px;
            pointer-events: auto;
            display: flex; justify-content: space-between; align-items: center;
        }

        /* CONTROL PANEL - RIGHT SIDE */
        #controls {
            position: absolute; top: 100px; right: 40px;
            width: 250px; background: rgba(10,10,10,0.8);
            border: 1px solid rgba(255,215,0,0.3);
            padding: 20px; color: #fff; pointer-events: auto;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        .control-group { margin-bottom: 20px; }
        .label { font-size: 10px; color: #888; margin-bottom: 5px; display: block; }
        
        /* CUSTOM SLIDER */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 6px;
            background: #fff; cursor: pointer; margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; background: #444;
        }

        /* BUTTONS */
        button {
            background: transparent; border: 1px solid #555; color: #aaa;
            padding: 8px 16px; width: 100%; cursor: pointer;
            font-family: inherit; text-transform: uppercase; font-size: 10px;
            transition: all 0.3s; margin-bottom: 5px;
        }
        button:hover { border-color: #D4AF37; color: #D4AF37; }
        button:active { background: #D4AF37; color: #000; }

        /* STATUS TEXT */
        #status-readout {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); font-size: 12px;
            text-align: center; pointer-events: none;
        }

        /* LOADING */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #D4AF37; pointer-events: none; transition: opacity 1s;}
    </style>
    
    <!-- UNIVERSAL SCRIPT LOADS (No Modules = Works in Chat Windows) -->
    <!-- Note: Using r128 for OrbitControls compatibility in global scope -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.160.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>

    <div id="loading">ESTABLISHING UPLINK...</div>

    <!-- UI LAYER -->
    <div id="ui-layer">
        <div id="hud-top">
            <span>ðŸ‘‘ God View</span>
            <span id="clock">00:00:00</span>
        </div>

        <div id="controls">
            <div class="control-group">
                <span class="label">COMPLEXITY THRESHOLD</span>
                <input type="range" id="threshold-slider" min="1" max="15" step="0.1" value="5">
                <div style="display:flex; justify-content:space-between; margin-top:5px; font-size:10px; color:#666;">
                    <span>DENSE</span>
                    <span>SPARSE</span>
                </div>
            </div>

            <div class="control-group">
                <span class="label">VISUAL MODE</span>
                <button id="btn-simulate-bug">Simulate Bug (Blue)</button>
                <button id="btn-fix-bug">Restore (Gold)</button>
            </div>
            
            <div class="control-group">
                <span class="label">SYSTEM STATUS</span>
                <div id="node-info" style="font-size: 10px; color: #D4AF37; margin-top: 5px;">
                    Select a Fiefdom to inspect.
                </div>
            </div>
        </div>

        <div id="status-readout">ORCHESTR8 v4.0 // CONNECTED</div>
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        // COLORS
        const COL_GOLD = new THREE.Color(0xD4AF37);
        const COL_BLUE = new THREE.Color(0x1fbdea);
        const COL_WISDOM = new THREE.Color(0xffffff);
        const COL_BG = new THREE.Color(0x050505);

        // SCENE SETUP
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
        renderer.setPixelRatio(window.devicePixelRatio > 1.5 ? 1.5 : window.devicePixelRatio); // Limit pixel ratio for performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = COL_BG;
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        // CAMERA - THE CASTLE ON THE HILL
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(40, 35, 40);
        camera.lookAt(0, 0, 0);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; 
        controls.minDistance = 10;
        controls.maxDistance = 100;

        // ==================== SHADERS ====================
        
        // Custom Shader for Lines (Handles Threshold and State)
        const lineVertexShader = `
            attribute vec3 color;
            attribute vec3 nextPos; 
            uniform float uTime;
            uniform float uThreshold;
            uniform float uState; 
            
            varying vec3 vColor;
            varying float vAlpha;
            varying float vDist;

            void main() {
                vec3 pos = position;

                // EDGE LENGTH CALCULATION
                float edgeLen = distance(pos, nextPos);

                // THRESHOLD SLIDER LOGIC
                // Uses Three.js smoothstep equivalent manually
                float t = (edgeLen - uThreshold) / 5.0;
                t = clamp(t, 0.0, 1.0);
                float density = 1.0 - (t * t * (3.0 - 2.0 * t)); // Smoothstep implementation
                
                // STATE LOGIC (Gold vs Blue)
                vec3 targetColor = color;
                float baseAlpha = density;

                if (uState > 0.5) {
                    // Blue State (Sadness)
                    targetColor = vec3(0.12, 0.74, 0.92); 
                    baseAlpha = density * 0.4; // Dimmer
                    // Shiver effect
                    float noise = sin(pos.x * 10.0 + uTime * 20.0) * 0.05;
                    pos.y += noise;
                } else {
                    // Gold State
                    targetColor = vec3(0.83, 0.68, 0.21); 
                }

                vColor = targetColor;
                vAlpha = baseAlpha;
                vDist = length(pos); 

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const lineFragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;
            varying float vDist;

            void main() {
                // DEPTH FOG
                float fogFactor = smoothstep(40.0, 10.0, vDist);
                float finalAlpha = vAlpha * fogFactor;
                if (finalAlpha < 0.01) discard;
                gl_FragColor = vec4(vColor, finalAlpha);
            }
        `;

        // ==================== FIEFDOM GENERATION ====================
        
        const fiefdoms = [];
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uThreshold: { value: 5.0 }, 
                uState: { value: 0.0 }     
            },
            vertexShader: lineVertexShader,
            fragmentShader: lineFragmentShader,
            transparent: true,
            depthWrite: false, 
            blending: THREE.AdditiveBlending
        });

        function createCrystal(x, z, sizeY, sizeXZ, density) {
            const segments = density; 
            const geometry = new THREE.BufferGeometry();
            
            const positions = [];
            const nextPositions = []; 
            const colors = [];

            for (let i = 0; i <= segments; i++) {
                for (let j = 0; j <= segments; j++) {
                    // Cube distorted by noise
                    const px = x + (Math.random() - 0.5) * sizeXZ;
                    const py = (Math.random() * sizeY) - (sizeY/2);
                    const pz = z + (Math.random() - 0.5) * sizeXZ;

                    // Wisdom Logic: Inner particles are white, outer are gold
                    const distFromCenter = Math.sqrt(Math.pow(px-x, 2) + Math.pow(pz-z, 2));
                    const maxDist = sizeXZ / 2;
                    
                    // Manual mix
                    let t = Math.max(0, Math.min(1, distFromCenter / maxDist));
                    const mixFactor = 1.0 - t;
                    
                    const r = THREE.MathUtils.lerp(COL_GOLD.r, COL_WISDOM.r, mixFactor);
                    const g = THREE.MathUtils.lerp(COL_GOLD.g, COL_WISDOM.g, mixFactor);
                    const b = THREE.MathUtils.lerp(COL_GOLD.b, COL_WISDOM.b, mixFactor);

                    positions.push(px, py, pz);
                    colors.push(r, g, b);
                    
                    nextPositions.push(px + 0.5, py + 0.5, pz + 0.5); 
                }
            }

            const indices = [];
            const count = segments + 1;
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * count + j;
                    const b = i * count + j + 1;
                    const c = (i + 1) * count + j;
                    const d = (i + 1) * count + j + 1;

                    indices.push(a, b);
                    indices.push(a, c);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('nextPos', new THREE.Float32BufferAttribute(nextPositions, 3)); 
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);

            const lines = new THREE.LineSegments(geometry, material.clone()); 
            lines.userData = { id: fiefdoms.length, state: 'gold', originalScale: 1.0 };
            scene.add(lines);
            fiefdoms.push(lines);
            
            return lines;
        }

        // Create the city
        createCrystal(0, 0, 20, 10, 8);    
        createCrystal(15, 10, 12, 6, 5);  
        createCrystal(-15, -10, 8, 8, 6); 
        createCrystal(5, -15, 15, 5, 10); 
        createCrystal(-10, 15, 6, 6, 4);  

        // ==================== INTERACTION ====================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;

        function onMouseClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(fiefdoms);

            if (intersects.length > 0) {
                diveToBuilding(intersects[0].object);
            } else {
                returnToCastle(); 
            }
        }
        window.addEventListener('click', onMouseClick);

        // ==================== CAMERA TRANSITIONS ====================
        
        let isDiving = false;
        const clock = new THREE.Clock();

        function diveToBuilding(target) {
            if (isDiving) return;
            isDiving = true;
            selectedObject = target;
            
            document.getElementById('node-info').innerText = `ACCESSING: FIEFDOM_${target.userData.id}`;
            document.getElementById('node-info').style.color = '#1fbdea';
            controls.enabled = false;
        }

        function returnToCastle() {
            isDiving = false;
            selectedObject = null;
            controls.enabled = true;
            document.getElementById('node-info').innerText = "Select a Fiefdom to inspect.";
            document.getElementById('node-info').style.color = "#D4AF37";
        }

        // ==================== ANIMATION LOOP ====================
        
        const thresholdSlider = document.getElementById('threshold-slider');
        thresholdSlider.addEventListener('input', (e) => {
            fiefdoms.forEach(f => {
                f.material.uniforms.uThreshold.value = parseFloat(e.target.value);
            });
        });

        document.getElementById('btn-simulate-bug').addEventListener('click', () => {
            if(selectedObject) {
                selectedObject.userData.state = 'blue';
                selectedObject.material.uniforms.uState.value = 1.0;
            }
        });

        document.getElementById('btn-fix-bug').addEventListener('click', () => {
            if(selectedObject) {
                selectedObject.userData.state = 'gold';
                selectedObject.material.uniforms.uState.value = 0.0;
            }
        });

        // Clock
        setInterval(() => {
            const now = new Date();
            document.getElementById('clock').innerText = now.toLocaleTimeString('en-US', { hour12: false });
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            
            fiefdoms.forEach(f => f.material.uniforms.uTime.value = time);

            if (isDiving && selectedObject) {
                const targetPos = new THREE.Vector3();
                selectedObject.geometry.computeBoundingSphere();
                selectedObject.localToWorld(selectedObject.geometry.boundingSphere.center.clone(), targetPos);

                const desiredCamPos = targetPos.clone().add(new THREE.Vector3(5, 2, 5)); 
                
                camera.position.lerp(desiredCamPos, 0.05);
                controls.target.lerp(targetPos, 0.05);
                camera.updateMatrixWorld(); 

                if (camera.position.distanceTo(desiredCamPos) < 0.5) {
                    isDiving = false; 
                }
            } else if (!controls.enabled) {
                 returnToCastle();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        document.getElementById('loading').style.opacity = 0;
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
```
