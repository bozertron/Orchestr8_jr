// C:\orchestr8\scripts\prd src\commandParser.ts
import path from 'path';
import fs from 'fs-extra';
import fg from 'fast-glob';

// --- Constants --- (Keep AS IS)
const TAURI_COMMANDS_SUBDIR = 'src-tauri/src/commands';
const FRONTEND_SUBDIRS = ['src'];
const INVOKE_PATTERN = /invoke\(\s*['"]([^'"]+)['"]/g;
const TAURI_COMMAND_PATTERN = /#\[tauri::command\][\s\n\r]*(?:pub\s*)?(?:async\s*)?fn\s+([a-zA-Z0-9_]+)/g;

// --- Type Definitions ---

// Options passed to functions
interface CommandParserOptions {
    comparePath?: string; // Example for future extension
}

// Structured data for analysis result
interface CommandDeclarationInfo { file: string; }
interface CommandInvocationInfo { files: string[]; } // files are relative paths or basenames
interface CommandAnalysisData {
    invocations: Record<string, CommandInvocationInfo>; // Map commandName -> { files: [...] }
    declarations: Record<string, CommandDeclarationInfo>; // Map commandName -> { file: ... }
}

// Standard Analysis Result types (can be moved to a shared types file later)
interface AnalysisSuccess<T> { success: true; data: T; }
interface AnalysisError { success: false; error: string; details?: any; }
type AnalysisResult<T> = AnalysisSuccess<T> | AnalysisError;


// --- Helper Functions --- (Keep findInvokeCalls & findTauriCommandDeclarations AS IS)
async function findInvokeCalls(basePath: string): Promise<Map<string, string[]>> { /* ... implementation ... */ }
async function findTauriCommandDeclarations(basePath: string): Promise<Map<string, { file: string }>> { /* ... implementation ... */ }


// --- NEW: Core Analysis Function ---
/**
 * Performs the core analysis for Tauri commands.
 * @param targetPath - Absolute path to the target directory or file.
 * @param options - Parser options (currently unused).
 * @returns Promise resolving to a structured analysis result.
 */
async function analyzeCommandData(
    targetPath: string,
    options: CommandParserOptions = {}
): Promise<AnalysisResult<CommandAnalysisData>> {
    console.log(`DEBUG [commands - analyze]: Starting analysis for target: ${targetPath}`);
    try {
        if (!(await fs.pathExists(targetPath))) {
            return { success: false, error: `Target path not found: ${targetPath}` };
        }

        const frontendResults = await findInvokeCalls(targetPath);
        const backendResults = await findTauriCommandDeclarations(targetPath);

        // Convert Maps to Records for easier JSON serialization if needed
        const invocations: Record<string, CommandInvocationInfo> = {};
        frontendResults.forEach((files, commandName) => {
            invocations[commandName] = { files: [...new Set(files)].sort() }; // Store unique, sorted files
        });

        const declarations: Record<string, CommandDeclarationInfo> = {};
        backendResults.forEach((details, commandName) => {
            declarations[commandName] = details;
        });

        console.log(`DEBUG [commands - analyze]: Analysis complete. Found ${Object.keys(invocations).length} invoked, ${Object.keys(declarations).length} declared.`);
        return {
            success: true,
            data: {
                invocations,
                declarations,
            }
        };
    } catch (error: any) {
        console.error(`ERROR [commands - analyze]: Unexpected error during analysis for ${targetPath}:`, error);
        return { success: false, error: `Command analysis failed: ${error.message}`, details: error.stack };
    }
}

// --- NEW: Report Formatting Function ---
/**
 * Formats the structured command analysis data into a string report.
 * @param data - The structured data from analyzeCommandData.
 * @returns The formatted report string.
 */
function formatCommandReport(data: CommandAnalysisData): string {
    // Determine context (was analysis run on file or directory? - We lose this info here, maybe add it to data?)
    // For now, assume directory context for cross-reference or make it simpler.
    let report = `=== Tauri Command Analysis ===\n`; // Simplified header
    report += `Analysis Time: ${new Date().toISOString()}\n\n`;

    // Section 1: Frontend Invokes
    report += `--- Frontend Invoke Calls ('invoke(...)') ---\n`;
    const invokedCommands = Object.keys(data.invocations).sort();
    if (invokedCommands.length === 0) {
        report += `(No frontend invokes found)\n`;
    } else {
        for (const commandName of invokedCommands) {
            const info = data.invocations[commandName];
            report += `Command: ${commandName}\n`;
            report += `  Invoked in: ${info.files.length} unique file(s)\n`;
            info.files.slice(0, 5).forEach(f => report += `    - ${f}\n`);
            if (info.files.length > 5) report += `    ... and ${info.files.length - 5} more\n`;
            report += "\n";
        }
    }

    // Section 2: Backend Declarations
    report += `\n--- Backend Command Declarations ('#[tauri::command]') ---\n`;
    const declaredCommands = Object.keys(data.declarations).sort();
    if (declaredCommands.length === 0) {
        report += `(No backend declarations found)\n`;
    } else {
        for (const commandName of declaredCommands) {
            const details = data.declarations[commandName];
            report += `Command: ${commandName}\n`;
            report += `  Declared in: ${details.file}\n`;
            report += "\n";
        }
    }

    // Section 3: Cross-Reference
    report += "\n--- Command Cross-Reference ---\n";
    const invokedSet = new Set(invokedCommands);
    const declaredSet = new Set(declaredCommands);

    const undeclared = invokedCommands.filter(cmd => !declaredSet.has(cmd));
    if (undeclared.length > 0) report += "Invoked But Not Declared:\n" + undeclared.map(cmd => `  - ${cmd}`).join('\n') + '\n';
    else report += "All invoked commands appear to have declarations.\n";

    const unused = declaredCommands.filter(cmd => !invokedSet.has(cmd));
    if (unused.length > 0) report += "\nDeclared But Not Invoked:\n" + unused.map(cmd => `  - ${cmd}`).join('\n') + '\n';
    else report += "\nAll declared commands appear to be invoked.\n";

    report += "\n=================================\n";
    return report;
}


// --- Plugin Exports ---

export const commandType = 'commands';
export const description = 'Analyzes Tauri commands (frontend invokes and backend declarations).';
export const supportsCompare = false; // Set true if/when compare logic is added to analyzeCommandData
export const specificOptions = undefined; // Add specific options here if needed

// Export the core analysis function
export { analyzeCommandData as analyzeDataFunction };

// Export the formatting function
export { formatCommandReport as formatReportFunction };

// Optional: Export a specific CLI wrapper (or let the CLI derive it)
/*
export async function cliParserFunction(
    targetPath: string,
    options: CommandParserOptions
): Promise<string> {
    const result = await analyzeCommandData(targetPath, options);
    if (result.success) {
        return formatCommandReport(result.data);
    } else {
        console.error(`[commands Plugin Error]: ${result.error}`, result.details ?? '');
        return `ERROR generating report for commands: ${result.error}`;
    }
}
*/
