<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Orchestr8: The Cluster</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* CONTROLS */
        #controls {
            position: absolute; top: 20px; right: 20px;
            width: 250px; background: rgba(10,10,10,0.9);
            border: 1px solid rgba(212, 175, 55, 0.3);
            padding: 20px; color: #fff; pointer-events: auto;
        }
        .label { font-size: 10px; color: #888; margin-bottom: 5px; display: block; text-transform: uppercase;}
        input[type=range] { width: 100%; cursor: pointer; }
    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="controls">
        <span class="label">District Complexity</span>
        <input type="range" id="threshold-slider" min="0.5" max="3.0" step="0.1" value="1.5">
        <p style="font-size:10px; color:#666; margin-top:5px;">
            Controls wireframe density.<br>
            Left = Suburban (Tight)<br>
            Right = Industrial (Sparse)
        </p>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // ==================== SETUP ====================
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0, 10, 25);
        camera.lookAt(0, 0, 0);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1;

        // POST PROCESSING
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloomPass.strength = 1.5; // Nice glow
        bloomPass.radius = 0.4;
        bloomPass.threshold = 0;
        composer.addPass(bloomPass);

        // ==================== SHADERS ====================
        const wireVertexShader = `
            attribute vec3 neighbor; 
            
            uniform float uThreshold;
            uniform float uTime;
            
            varying vec3 vColor;
            varying float vAlpha;

            void main() {
                vec3 pos = position;
                float edgeLen = distance(pos, neighbor);
                
                // THRESHOLD LOGIC
                float alpha = 1.0 - smoothstep(uThreshold, uThreshold + 0.5, edgeLen);
                
                // COLOR LOGIC (Wisdom Gradient)
                // Inner core white, outer gold
                float dist = length(pos);
                float wisdom = 1.0 - smoothstep(0.0, 1.5, dist);
                vec3 coreColor = vec3(1.0, 1.0, 1.0);
                vec3 shellColor = vec3(0.83, 0.68, 0.21); // Gold
                
                vColor = mix(coreColor, shellColor, wisdom);
                vAlpha = alpha;

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const wireFragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;
            void main() {
                if (vAlpha < 0.01) discard;
                gl_FragColor = vec4(vColor, vAlpha);
            }
        `;

        const material = new THREE.ShaderMaterial({
            uniforms: {
                uThreshold: { value: 1.5 },
                uTime: { value: 0 }
            },
            vertexShader: wireVertexShader,
            fragmentShader: wireFragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        // ==================== GENERATE CLUSTER ====================
        
        // We create a "Ring" of Monoliths
        const monoliths = [];
        const numBuildings = 6;
        const radius = 8; // Spread of the cluster

        for(let i=0; i<numBuildings; i++) {
            const angle = (i / numBuildings) * Math.PI * 2;
            const x = Math.cos(angle) * radius + (Math.random()-0.5);
            const z = Math.sin(angle) * radius + (Math.random()-0.5);
            const y = (Math.random() - 0.5) * 3; // Slight height variation
            
            const size = 2 + Math.random() * 2;
            
            // 1. Create Geometry (Icosahedron)
            const geometry = new THREE.IcosahedronGeometry(size, 2);
            
            // 2. Distort Vertices (Organic growth)
            const pos = geometry.attributes.position.array;
            for(let j=0; j<pos.length; j+=3) {
                pos[j] += (Math.random()-0.5) * (size * 0.1);
                pos[j+1] += (Math.random()-0.5) * (size * 0.1);
                pos[j+2] += (Math.random()-0.5) * (size * 0.1);
            }
            geometry.attributes.position.needsUpdate = true;
            geometry.computeVertexNormals();

            // 3. Convert to LineSegments (with neighbor data)
            const posAttr = geometry.attributes.position;
            const count = posAttr.count;
            const newPositions = [];
            const newNeighbors = [];

            for(let j=0; j<count; j++) {
                const v1 = new THREE.Vector3().fromBufferAttribute(posAttr, j);
                const nextIdx = (j + 1) % count; // Simple loop neighbor
                const v2 = new THREE.Vector3().fromBufferAttribute(posAttr, nextIdx);
                
                newPositions.push(v1.x, v1.y, v1.z);
                newNeighbors.push(v2.x, v2.y, v2.z);
            }

            const lineGeo = new THREE.BufferGeometry();
            lineGeo.setAttribute('position', new THREE.Float32BufferAttribute(newPositions, 3));
            lineGeo.setAttribute('neighbor', new THREE.Float32BufferAttribute(newNeighbors, 3));

            const lines = new THREE.LineSegments(lineGeo, material);
            scene.add(lines);
            monoliths.push(lines);
        }

        // ==================== LOOP ====================
        const clock = new THREE.Clock();
        
        document.getElementById('threshold-slider').addEventListener('input', (e) => {
            material.uniforms.uThreshold.value = parseFloat(e.target.value);
        });

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            material.uniforms.uTime.value = time;
            
            // Slowly rotate the entire cluster
            scene.rotation.y = time * 0.1;

            controls.update();
            composer.render();
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
