<!DOCTYPE html>
<html lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
				<meta charset="UTF-8">
				<meta name="viewport" content="width=device-width, initial-scale=1.0">
				<style>
					body {
						background-color: white; /* Ensure the iframe has a white background */
					}
				</style>
				<script>
					const CDN_WHITELIST = [
						'cdn.jsdelivr.net',
						'cdnjs.cloudflare.com',
						'cdn.tailwindcss.com',
						'unpkg.com',
						'fonts.googleapis.com',
						'd3js.org',
						'cdn.babylonjs.com',
						'html2canvas.hertzen.com',
						'code.jquery.com',
						'cdn.datatables.net',
						'kit.fontawesome.com',
						'code.createjs.com',
						'cdn.plot.ly',
						'fonts.gstatic.com',
						'www.rgraph.net',
						'api.mapbox.com',
						'polyfill.io',
						'cdn.quilljs.com',
						'picsum.photos',
						'esm.sh'
					];

					function isUrlInWhitelist(url) {
						if (!url || typeof url !== 'string') {
							return false;
						}
						try {
							const urlObj = new URL(url);
							const hostname = urlObj.hostname;
							return CDN_WHITELIST.some(domain => hostname === domain || hostname.endsWith('.' + domain));
						} catch (e) {
							return false;
						}
					}

					function proxyCdnUrl(url) {
						if (!url || !url.startsWith('http')) {
							return url;
						}
						if (url && (url.startsWith('http://') || url.startsWith('https://')) && !url.startsWith('https://artifacts-cdn.chatglm.site/')) {
							const proxiedUrl = 'https://artifacts-cdn.chatglm.site/' + url;
							return proxiedUrl;
						}
						return url;
					}

					const rawCreateElement = document.createElement;

					document.createElement = function (tagName, ...args) {
						const el = rawCreateElement.call(this, tagName, ...args);

						if (tagName.toLowerCase() === 'script') {
							const rawSetAttribute = el.setAttribute;
							const rawGetAttribute = el.getAttribute;
							let srcValue = '';
							
							el.setAttribute = function (name, value) {
								if (name === 'src' && typeof value === 'string') {
									value = proxyCdnUrl(value);
									srcValue = value;
								}
								return rawSetAttribute.call(this, name, value);
							};

							Object.defineProperty(el, 'src', {
								get: function() {
									return srcValue || rawGetAttribute.call(this, 'src') || '';
								},
								set: function(value) {
									if (typeof value === 'string') {
										srcValue = proxyCdnUrl(value);
										rawSetAttribute.call(this, 'src', srcValue);
									} else {
										srcValue = value;
									}
								},
								configurable: true,
								enumerable: true
							});
						}

						if (tagName.toLowerCase() === 'link') {
							const rawSetAttribute = el.setAttribute;
							const rawGetAttribute = el.getAttribute;
							let hrefValue = '';
							
							el.setAttribute = function (name, value) {
								if (name === 'href' && typeof value === 'string') {
									value = proxyCdnUrl(value);
									hrefValue = value;
								}
								return rawSetAttribute.call(this, name, value);
							};

							Object.defineProperty(el, 'href', {
								get: function() {
									return hrefValue || rawGetAttribute.call(this, 'href') || '';
								},
								set: function(value) {
									if (typeof value === 'string') {
										hrefValue = proxyCdnUrl(value);
										rawSetAttribute.call(this, 'href', hrefValue);
									} else {
										hrefValue = value;
									}
								},
								configurable: true,
								enumerable: true
							});
						}

						return el;
					};

					const OriginalXMLHttpRequest = window.XMLHttpRequest;
					window.XMLHttpRequest = function (...args) {
						const xhr = new OriginalXMLHttpRequest(...args);
						const rawOpen = xhr.open;

						xhr.open = function (method, url, ...rest) {
							if (typeof url === 'string') {
								const methodUpper = (method || '').toUpperCase();
								if (methodUpper === 'GET' && isUrlInWhitelist(url)) {
									url = proxyCdnUrl(url);
								}
							}
							return rawOpen.call(this, method, url, ...rest);
						};

						return xhr;
					};

					window.XMLHttpRequest.prototype = OriginalXMLHttpRequest.prototype;
					Object.setPrototypeOf(window.XMLHttpRequest, OriginalXMLHttpRequest);

					const originalFetch = window.fetch;
					window.fetch = async function (...args) {
						if (args.length > 0) {
							let url = '';
							let method = 'GET';
							
							if (typeof args[0] === 'string') {
								url = args[0];
								if (args[1] && args[1].method) {
									method = args[1].method.toUpperCase();
								}
								if (method === 'GET' && isUrlInWhitelist(url)) {
									args[0] = proxyCdnUrl(url);
								}
							} else if (args[0] instanceof Request) {
								const originalUrl = args[0].url;
								method = (args[0].method || 'GET').toUpperCase();
								if (method === 'GET' && isUrlInWhitelist(originalUrl)) {
									const proxiedUrl = proxyCdnUrl(originalUrl);
									if (proxiedUrl !== originalUrl) {
										args[0] = new Request(proxiedUrl, args[0]);
									}
								}
							}
						}
						return originalFetch.apply(this, args);
					};
				</script>
			</head>
			<body>
				
    <meta charset="UTF-8">
    <title>Crystal City: The Window</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'Courier New', monospace; }
        canvas { display: block; width: 100vw; height: 100vh; }
        
        /* UI OVERLAY - HUD STYLE */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; /* Let clicks pass through to 3D */
            display: flex; flex-direction: column; justify-content: space-between;
        }

        /* TOP BAR - THE "TV" FRAME */
        #hud-top {
            padding: 20px 40px; 
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            color: rgba(255,255,255,0.8);
            text-transform: uppercase; letter-spacing: 3px;
            font-size: 12px;
            pointer-events: auto;
            display: flex; justify-content: space-between; align-items: center;
        }

        /* CONTROL PANEL - RIGHT SIDE */
        #controls {
            position: absolute; top: 100px; right: 40px;
            width: 250px; background: rgba(10,10,10,0.8);
            border: 1px solid rgba(255,215,0,0.3);
            padding: 20px; color: #fff; pointer-events: auto;
            backdrop-filter: blur(5px);
        }

        .control-group { margin-bottom: 20px; }
        .label { font-size: 10px; color: #888; margin-bottom: 5px; display: block; }
        
        /* CUSTOM SLIDER */
        input[type=range] {
            -webkit-appearance: none; width: 100%; background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 16px; width: 6px;
            background: #fff; cursor: pointer; margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%; height: 2px; background: #444;
        }

        /* BUTTONS */
        button {
            background: transparent; border: 1px solid #555; color: #aaa;
            padding: 8px 16px; width: 100%; cursor: pointer;
            font-family: inherit; text-transform: uppercase; font-size: 10px;
            transition: all 0.3s;
        }
        button:hover { border-color: #D4AF37; color: #D4AF37; }
        button.active { background: #D4AF37; color: #000; border-color: #D4AF37; }

        /* STATUS TEXT */
        #status-readout {
            position: absolute; bottom: 40px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.5); font-size: 12px;
            text-align: center; pointer-events: none;
        }

        /* LOADING */
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: #D4AF37; pointer-events: none; transition: opacity 1s;}
    </style>
    <!-- Import Map -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>



    <div id="loading">ESTABLISHING UPLINK...</div>

    <!-- UI LAYER -->
    <div id="ui-layer">
        <div id="hud-top">
            <span>ðŸ‘‘ God View</span>
            <span id="clock">00:00:00</span>
        </div>

        <div id="controls">
            <div class="control-group">
                <span class="label">COMPLEXITY THRESHOLD</span>
                <input type="range" id="threshold-slider" min="1" max="15" step="0.1" value="5">
                <div style="display:flex; justify-content:space-between; margin-top:5px; font-size:10px; color:#666;">
                    <span>DENSE</span>
                    <span>SPARSE</span>
                </div>
            </div>

            <div class="control-group">
                <span class="label">VISUAL MODE</span>
                <button id="btn-simulate-bug" style="margin-bottom: 5px;">Simulate Bug (Blue)</button>
                <button id="btn-fix-bug">Restore (Gold)</button>
            </div>
            
            <div class="control-group">
                <span class="label">SYSTEM STATUS</span>
                <div id="node-info" style="font-size: 10px; color: #D4AF37; margin-top: 5px;">
                    Select a Fiefdom to inspect.
                </div>
            </div>
        </div>

        <div id="status-readout">ORCHESTR8 v4.0 // CONNECTED</div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // ==================== CONFIGURATION ====================
        // COLORS
        const COL_GOLD = new THREE.Color(0xD4AF37);
        const COL_BLUE = new THREE.Color(0x1fbdea);
        const COL_WISDOM = new THREE.Color(0xffffff);
        const COL_BG = new THREE.Color(0x050505);

        // SCENE SETUP
        const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: false });
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap pixel ratio for performance
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const scene = new THREE.Scene();
        scene.background = COL_BG;
        // Exponential fog for the "Endless Void" feel
        scene.fog = new THREE.FogExp2(0x050505, 0.015);

        // CAMERA - THE CASTLE ON THE HILL
        // High up, angled down.
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(40, 35, 40);
        camera.lookAt(0, 0, 0);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.maxPolarAngle = Math.PI / 2 - 0.1; // Don't go below ground
        controls.minDistance = 10;
        controls.maxDistance = 100;

        // ==================== SHADERS (THE BARRADEAU LOOK) ====================
        
        // We use a custom shader for lines to handle the "Threshold" logic efficiently on GPU.
        
        const lineVertexShader = `
            attribute vec3 color;
            attribute vec3 nextPos; // The position of the connected point
            attribute float lineIndex;
            
            uniform float uTime;
            uniform float uThreshold;
            uniform float uState; // 0=Gold, 1=Blue(Broken)
            
            varying vec3 vColor;
            varying float vAlpha;
            varying float vDist;

            void main() {
                vec3 pos = position;

                // CALCULATE EDGE LENGTH (The Barradeau Trick)
                float edgeLen = distance(pos, nextPos);

                // VISUAL LOGIC:
                // If edge is too long (sparse), fade it out based on threshold slider
                // We use smoothstep for a nice gradient transition
                float density = 1.0 - smoothstep(uThreshold, uThreshold + 5.0, edgeLen);
                
                // STATE LOGIC (Gold vs Blue):
                // If Blue (Broken), make lines dimmer and shiver
                vec3 targetColor = color;
                float baseAlpha = density;

                if (uState > 0.5) {
                    // Blue State
                    targetColor = vec3(0.12, 0.74, 0.92); // Blue
                    baseAlpha = density * 0.4; // Dimmer
                    // Shiver effect
                    float noise = sin(pos.x * 10.0 + uTime * 20.0) * 0.05;
                    pos.y += noise;
                } else {
                    // Gold State
                    targetColor = vec3(0.83, 0.68, 0.21); // Gold
                }

                vColor = targetColor;
                vAlpha = baseAlpha;
                vDist = length(pos); // For depth fog

                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const lineFragmentShader = `
            varying vec3 vColor;
            varying float vAlpha;
            varying float vDist;

            void main() {
                // DEPTH FOG
                // Fade out lines further away to create volume
                float fogFactor = smoothstep(40.0, 10.0, vDist);
                
                // Combine density alpha and fog alpha
                float finalAlpha = vAlpha * fogFactor;

                if (finalAlpha < 0.01) discard;

                gl_FragColor = vec4(vColor, finalAlpha);
            }
        `;

        // ==================== FIEFDOM GENERATION ====================
        
        // We generate "Wireframe Crystals". 
        // Instead of random points, we use a grid to create structural "buildings".

        const fiefdoms = [];
        const material = new THREE.ShaderMaterial({
            uniforms: {
                uTime: { value: 0 },
                uThreshold: { value: 5.0 }, // Controlled by slider
                uState: { value: 0.0 }     // 0 = Gold, 1 = Blue
            },
            vertexShader: lineVertexShader,
            fragmentShader: lineFragmentShader,
            transparent: true,
            depthWrite: false, // Important for transparency
            blending: THREE.AdditiveBlending
        });

        function createCrystal(x, z, sizeY, sizeXZ, density) {
            // Create a grid of vertices
            const segments = density; 
            const geometry = new THREE.BufferGeometry();
            
            const positions = [];
            const nextPositions = []; // Store connected neighbor for edge length calc
            const colors = [];

            for (let i = 0; i <= segments; i++) {
                for (let j = 0; j <= segments; j++) {
                    // Grid logic
                    const u = i / segments;
                    const v = j / segments;

                    // Map to sphere/cube shape
                    const phi = Math.acos(-1 + (2 * i) / segments);
                    const theta = Math.sqrt(segments * Math.PI) * phi;

                    // Or simpler: Cube distorted by noise
                    const px = x + (Math.random() - 0.5) * sizeXZ;
                    const py = (Math.random() * sizeY) - (sizeY/2);
                    const pz = z + (Math.random() - 0.5) * sizeXZ;

                    // Wisdom Logic: Inner particles are white, outer are gold
                    const distFromCenter = Math.sqrt(Math.pow(px-x, 2) + Math.pow(pz-z, 2));
                    const maxDist = sizeXZ / 2;
                    const mixFactor = 1.0 - smoothstep(0, maxDist, distFromCenter);
                    
                    const col = new THREE.Color().lerpColors(COL_GOLD, COL_WISDOM, mixFactor);

                    positions.push(px, py, pz);
                    colors.push(col.r, col.g, col.b);
                    
                    // For this demo, nextPos is just a dummy neighbor. 
                    // In a real connected mesh, we'd pass the actual connected vertex.
                    // Here, we simulate "structural integrity" by connecting to a slightly offset point.
                    nextPositions.push(px + 0.5, py + 0.5, pz + 0.5); 
                }
            }

            // We need explicit indices to draw lines (LINES mode)
            // This creates the "Wireframe" look.
            const indices = [];
            const count = segments + 1;
            for (let i = 0; i < segments; i++) {
                for (let j = 0; j < segments; j++) {
                    const a = i * count + j;
                    const b = i * count + j + 1;
                    const c = (i + 1) * count + j;
                    const d = (i + 1) * count + j + 1;

                    // Add lines for grid
                    indices.push(a, b);
                    indices.push(a, c);
                    // indices.push(b, d); // Diagonal - optional
                    // indices.push(c, d);
                }
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('nextPos', new THREE.Float32BufferAttribute(nextPositions, 3)); // Hack for length calc
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setIndex(indices);

            const lines = new THREE.LineSegments(geometry, material.clone()); // Clone mat so they can have independent states
            lines.userData = { id: fiefdoms.length, state: 'gold', originalScale: 1.0 };
            scene.add(lines);
            fiefdoms.push(lines);
            
            return lines;
        }

        // Create a city of crystals
        // "Minuscule" (small functions) to "Gigantic" (systems)
        createCrystal(0, 0, 20, 10, 8);    // Center Tower (Wisdom)
        createCrystal(15, 10, 12, 6, 5);  // Right Tower
        createCrystal(-15, -10, 8, 8, 6); // Left Tower
        createCrystal(5, -15, 15, 5, 10); // Far Tower
        createCrystal(-10, 15, 6, 6, 4);  // Small Outpost

        // ==================== INTERACTION ====================
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let selectedObject = null;

        function onMouseClick(event) {
            // Calculate mouse position in normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(fiefdoms);

            if (intersects.length > 0) {
                const target = intersects[0].object;
                diveToBuilding(target);
            } else {
                returnToCastle(); // Click void to go back
            }
        }
        window.addEventListener('click', onMouseClick);

        // ==================== CAMERA TRANSITIONS (MATRIX DIVE) ====================
        
        let isDiving = false;
        const clock = new THREE.Clock();

        function diveToBuilding(target) {
            if (isDiving) return;
            isDiving = true;
            selectedObject = target;
            
            document.getElementById('node-info').innerText = `ACCESSING: FIEFDOM_${target.userData.id}`;
            document.getElementById('node-info').style.color = '#1fbdea';

            // Disable controls during dive
            controls.enabled = false;
        }

        function returnToCastle() {
            isDiving = false;
            selectedObject = null;
            controls.enabled = true;
            document.getElementById('node-info').innerText = "Select a Fiefdom to inspect.";
            document.getElementById('node-info').style.color = "#D4AF37";
        }

        // ==================== ANIMATION LOOP ====================
        
        // UI BINDINGS
        const thresholdSlider = document.getElementById('threshold-slider');
        thresholdSlider.addEventListener('input', (e) => {
            // Update all fiefdoms
            fiefdoms.forEach(f => {
                f.material.uniforms.uThreshold.value = parseFloat(e.target.value);
            });
        });

        document.getElementById('btn-simulate-bug').addEventListener('click', () => {
            if(selectedObject) {
                selectedObject.userData.state = 'blue';
                selectedObject.material.uniforms.uState.value = 1.0;
            }
        });

        document.getElementById('btn-fix-bug').addEventListener('click', () => {
            if(selectedObject) {
                selectedObject.userData.state = 'gold';
                selectedObject.material.uniforms.uState.value = 0.0;
            }
        });

        // Clock
        setInterval(() => {
            const now = new Date();
            document.getElementById('clock').innerText = now.toLocaleTimeString('en-US', { hour12: false });
        }, 1000);

        function animate() {
            requestAnimationFrame(animate);
            
            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            // Update Time Uniform
            fiefdoms.forEach(f => f.material.uniforms.uTime.value = time);

            // "MATRIX" CAMERA LOGIC
            if (isDiving && selectedObject) {
                // Get world position of center of object (approximate)
                const targetPos = new THREE.Vector3();
                selectedObject.geometry.boundingSphere = new THREE.Sphere();
                selectedObject.geometry.computeBoundingSphere();
                selectedObject.localToWorld(selectedObject.geometry.boundingSphere.center.clone(), targetPos);

                // Lerp camera towards the building
                // We want to end up close and looking at it
                const desiredCamPos = targetPos.clone().add(new THREE.Vector3(5, 2, 5)); // Offset
                
                camera.position.lerp(desiredCamPos, 0.05);
                controls.target.lerp(targetPos, 0.05);
                camera.updateMatrixWorld(); // Important for raycaster

                // Check if we arrived
                if (camera.position.distanceTo(desiredCamPos) < 0.5) {
                    isDiving = false; // Stop auto-move, let user rotate around building
                }
            } else if (!controls.enabled) {
                 // If we stopped diving but controls aren't enabled yet (user clicked void)
                 returnToCastle();
            }

            controls.update();
            renderer.render(scene, camera);
        }

        // Remove loader
        document.getElementById('loading').style.opacity = 0;
        
        animate();

        // Resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>


			
		
<canvas style="display: block; width: 808px; height: 651px; touch-action: none;" data-engine="three.js r160" width="1010" height="813"></canvas></body></html>