---
phase: 08-design-ui-system
plan: 05
type: execute
wave: 2
depends_on: ["08-02", "08-04"]
files_modified:
  - IP/plugins/07_settings.py
  - pyproject_orchestr8_settings.toml
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Settings TOML schema is documented and validated"
    - "Settings changes sync to UI within 50ms"
    - "Settings persist across application restarts"
    - "CSE control surfaces have audit trail"
  artifacts:
    - path: "IP/plugins/07_settings.py"
      provides: "CSE-ready settings with single-pass wiring"
      contains: "SettingsService"
    - path: "pyproject_orchestr8_settings.toml"
      provides: "Settings persistence with documented schema"
      contains: "\\[ui\\]"
  key_links:
    - from: "SettingsManager"
      to: "pyproject_orchestr8_settings.toml"
      via: "toml load/dump"
      pattern: "toml\\.(load|dump)"
---

<objective>
Prepare the CSE (Comprehensive Settings Environment) single-pass wiring architecture. Implement settings service layer that combines logic + persistence + UI simultaneously, per PHREAK_CSE_RESEARCH_REPORT.md.

Purpose: The CSE architecture eliminates logic/persistence/UI drift by implementing all three simultaneously. This plan scaffolds the service layer and documents the TOML schema for future SettingsService integration.
</objective>

<execution_context>
@/home/bozertron/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/bozertron/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@IP/plugins/07_settings.py - Current settings implementation
@pyproject_orchestr8_settings.toml - Current settings structure
@SOT/CODEBASE_TODOS/PHREAK_CSE_RESEARCH_REPORT.md - CSE architecture spec
@.planning/phases/08-design-ui-system/08-02-PLAN.md - Depends on Pydantic validation
@.planning/phases/08-design-ui-system/08-04-PLAN.md - Depends on font profile
</context>

<tasks>

<task type="auto">
  <name>Document TOML settings schema</name>
  <files>pyproject_orchestr8_settings.toml</files>
  <action>
    Document and validate the TOML settings schema:

    1. Add schema documentation comments to pyproject_orchestr8_settings.toml:
       ```toml
       # Orchestr8 Settings Schema
       # ========================
       # This file uses dotted path notation for nested settings.
       # Format: section.subsection.key = value
       #
       # Sections:
       # - agents: AI agent configurations
       # - tools: Tool enable/disable and settings
       # - ui: User interface preferences
       # - logging: Logging configuration
       
       [ui]
       [ui.general]
       # font_profile: Select font profile (phreak_nexus, regal_deco, etc.)
       # animation_enabled: Enable/disable emergence animations
       # theme: Color theme (void, light)
       
       [ui.code_city]
       # max_bytes: Maximum payload size for Code City
       # stream_bps: Streaming rate for 3D buildings
       
       [agents]
       [agents.director]
       # enabled: Enable/disable director agent
       # check_interval_seconds: Health check interval
       
       [tools]
       [tools.actu8]
       # enabled: Tool is active
       ```

    2. Validate current TOML is parseable:
       ```python
       import toml
       toml.load("pyproject_orchestr8_settings.toml")
       ```

    3. Add missing sections if needed to complete schema coverage
  </action>
  <verify>
    python -c "import toml; s=toml.load('pyproject_orchestr8_settings.toml'); print('Sections:', list(s.keys()))"
  </verify>
  <done>
    TOML schema is documented with comments and validates correctly
  </done>
</task>

<task type="auto">
  <name>Implement SettingsService scaffold</name>
  <files>IP/plugins/07_settings.py</files>
  <action>
    Create SettingsService class as typesafe source of truth:

    1. Add SettingsService class that wraps SettingsManager:
       ```python
       class SettingsService:
           """
           Typesafe source of truth for Orchestr8 settings.
           Combines logic + persistence + UI in single-pass wiring.
           """
           
           def __init__(self):
               self._manager = SettingsManager()
               self._subscribers: list[callable] = []
           
           # Typesafe getters
           def get_font_profile(self) -> str:
               """Get current font profile."""
               return self._manager.settings.get("ui", {}).get("general", {}).get("font_profile", "phreak_nexus")
           
           def get_animation_enabled(self) -> bool:
               """Check if emergence animations are enabled."""
               return self._manager.settings.get("ui", {}).get("general", {}).get("animation_enabled", True)
           
           # Typesafe setters with immediate sync
           def set_font_profile(self, profile: str) -> None:
               """Set font profile with immediate UI sync."""
               self._set_nested(["ui", "general", "font_profile"], profile)
               self._notify_subscribers()
           
           # Real-time sync
           def subscribe(self, callback: callable) -> None:
               """Subscribe to settings changes."""
               self._subscribers.append(callback)
           
           def _notify_subscribers(self) -> None:
               """Notify all subscribers of change (<50ms target)."""
               for callback in self._subscribers:
                   callback(self._manager.settings)
           
           # Persistence
           def save(self) -> None:
               """Persist settings to TOML."""
               self._manager.save_settings()
           
           def reload(self) -> None:
               """Reload settings from TOML."""
               self._manager.load_settings()
               self._notify_subscribers()
       ```

    2. Add quantum commit pulse feedback (visual indicator):
       ```python
       def quantum_commit(self, key: str, value: Any) -> dict:
           """
           Commit a setting with audit trail.
           Returns: {key, value, timestamp, status}
           """
           # Record action for audit
           self._record_action(key, value)
           
           # Apply immediately
           self.set(key, value)
           
           return {
               "key": key,
               "value": value,
               "timestamp": datetime.now().isoformat(),
               "status": "committed"
           }
       ```

    3. Add Glitch color feedback for validation:
       ```python
       def validate_setting(self, key: str, value: Any) -> tuple[bool, str]:
           """
           Validate a setting value.
           Returns: (is_valid, error_message)
           """
           # Use Pydantic validators from 08-02
           # Return (False, "error") for invalid - triggers glitch effect
           # Return (True, "") for valid - triggers gold glow
       ```

    4. Add Action Inspector event tracking:
       ```python
       def _record_action(self, key: str, value: Any) -> None:
           """Record action for audit trail."""
           # Append to temporal_state ledger
           # Format: {timestamp, key, old_value, new_value, source}
       ```
  </action>
  <verify>
    python -c "
from IP.plugins.seven_settings import SettingsService
svc = SettingsService()
print('SettingsService initialized')
print('Font profile:', svc.get_font_profile())
"
  </verify>
  <done>
    SettingsService provides typesafe access with real-time sync
  </done>
</task>

<task type="auto">
  <name>Integrate SettingsService with UI</name>
  <files>IP/plugins/07_settings.py</files>
  <action>
    Wire SettingsService into the Settings UI:

    1. Replace direct SettingsManager usage with SettingsService:
       - Import SettingsService at top
       - Create global instance: `_settings_service = SettingsService()`
       - Use service for all get/set operations

    2. Add real-time preview for settings changes:
       - Subscribe UI render to settings changes
       - When setting changes, trigger re-render
       - Target: <50ms from change to visual update

    3. Add quantum commit visual feedback:
       - When save completes, show brief gold pulse
       - Duration: ~300ms
       - Effect: border glow or button flash

    4. Add glitch feedback for validation errors:
       - Invalid input: brief teal/glitch effect
       - Valid input: gold border flash

    5. Wire up Action Inspector if UI exists:
       - Log all setting changes
       - Include timestamp, key, old/new value
  </action>
  <verify>
    grep -q "SettingsService" IP/plugins/07_settings.py && \
    grep -q "subscribe" IP/plugins/07_settings.py
  </verify>
  <done>
    Settings UI uses SettingsService with real-time sync
  </done>
</task>

</tasks>

<verification>
1. Run `marimo run orchestr8.py`
2. Open Settings tab
3. Change font profile - UI updates within 50ms
4. Enter invalid value - Glitch feedback shows
5. Save settings - Quantum commit pulse visible
6. Check TOML file - Changes persisted
7. Reload page - Settings restored from TOML
</verification>

<success_criteria>
- SettingsService provides typesafe get/set methods
- UI reflects changes within 50ms
- Invalid values show Glitch feedback
- Valid saves show Quantum commit pulse
- All changes persist to TOML
- Settings reload correctly on app restart
</success_criteria>

<output>
After completion, create `.planning/phases/08-design-ui-system/08-05-SUMMARY.md`
</output>
