# README.AGENTS — Persistent Memory & Sidecar Guide

This document explains how AI agents in Orchestr8 use persistent memory and sidecar integration files.

## 1. Memory Infrastructure

### Components

- **claude-mem worker**: `127.0.0.1:37777` (MCP backend)
- **Shared Memory Gateway**: `127.0.0.1:37888` (Universal HTTP API)
- **Backend store**: `~/.claude-mem` (shared across all agents)

### Operations

```bash
# Start the memory stack
bash .taskmaster/tools/memory-gateway/memory-stack.sh start

# Check status
bash .taskmaster/tools/memory-gateway/memory-stack.sh status

# Stop the memory stack
bash .taskmaster/tools/memory-gateway/memory-stack.sh stop
```

## 2. Memory Gateway API

### Endpoints

| Endpoint | Method | Purpose |
|----------|--------|---------|
| `/v1/memory/brief` | GET/POST | Budget-capped shortlist + observation IDs |
| `/v1/memory/graph` | GET/POST | Relationship graph (query/file/risk/anchor) |
| `/v1/memory/search` | GET/POST | Search memory index |
| `/v1/memory/timeline` | GET/POST | Timeline around anchor/query |
| `/v1/memory/observations` | POST | Fetch full observation payloads |
| `/v1/memory/save` | POST | Manual memory write |
| `/v1/memory/health` | GET | Gateway + worker health check |
| `/v1/memory/schema` | GET | Capability + endpoint schema |

### Anti-15K Strategy

Use **staged retrieval** to avoid context overload:

1. **Brief** — Shortlist files + IDs under fixed budget
2. **Graph** — Understand relationship neighborhoods
3. **Observations** — Only fetch selected IDs

### Example Queries

```bash
# Search memory
curl -s "http://127.0.0.1:37888/v1/memory/search?query=code+city&limit=5"

# Get brief with budget cap
curl -s "http://127.0.0.1:37888/v1/memory/brief?q=code+city&budget=1600&file_limit=6"

# Get relationship graph
curl -s "http://127.0.0.1:37888/v1/memory/graph?q=node+click+bridge&file_limit=8&anchor_limit=3"

# Save observation
curl -s -X POST "http://127.0.0.1:37888/v1/memory/save" \
  -H "Content-Type: application/json" \
  -d '{"title":"Code City lock","text":"Three-state color system: Gold/Teal/Purple"}'

# Fetch specific observations
curl -s -X POST "http://127.0.0.1:37888/v1/memory/observations" \
  -H "Content-Type: application/json" \
  -d '{"ids":[1,2,3]}'
```

## 3. Sidecar File System

### Location

Sidecars live in `.taskmaster/docs/file-guides/`, mirroring the source tree structure:

```
.taskmaster/docs/file-guides/
├── _SORT_BY_FILENAME.tsv           # Master index
├── IP/
│   ├── woven_maps.py.integration.md    # Markdown guide
│   └── woven_maps.py.integration.json  # JSON metadata
└── orchestr8.py.integration.md
```

### File Types

For each source file, create **two** sidecar files:

1. `{name}.integration.md` — Human-readable guide (anchors, risks, gaps)
2. `{name}.integration.json` — Machine-readable metadata

### CRITICAL RULE

**When you modify a source file, UPDATE its sidecar files.**

This ensures:
- Line numbers stay accurate
- Resolved gaps are tracked
- New anchors are documented
- SHA256 hash is updated

## 4. Sidecar Format

### Markdown Format (`.integration.md`)

```markdown
# {filename} Integration Guide

- Source: `{path}/{filename}`
- Total lines: `{line_count}`
- SHA256: `{hash}`
- Role: **{one-line purpose}**

## Why This Is Painful

[List integration challenges, constraints, architectural trade-offs]

## Anchor Lines

- `{path}:{line}` — {description}
- `{path}:{line}` — {description}

## Integration Use

[How other modules interact with this file]

## Resolved Gaps

- [x] {gap_description}
- [x] {gap_description}

## Integration Gaps

- [ ] {gap_description}
```

### JSON Format (`.integration.json`)

```json
{
  "source": "IP/woven_maps.py",
  "total_lines": 3451,
  "sha256": "40e91786ca54617d8ab8f9fdae6ad1b636982aadaa82cbccbf77259410332171",
  "role": "Code City visualization — Canvas2D + WebGPU dual backend",
  "risks": [
    "Monolith: one file owns scan/layout + template + interaction",
    "Iframe sandbox constraints require bridge-safe communication"
  ],
  "anchors": [
    {"line": 67, "text": "class CodeNode — canonical node model"},
    {"line": 279, "text": "compute_building_geometry(lines, exports)"}
  ],
  "integration_gaps": [
    {
      "gap": "Patchbay rewiring interaction contract",
      "status": "pending",
      "notes": "No drag-to-rewire import rewrite flow yet."
    }
  ],
  "resolved_gaps": [
    {
      "gap": "Building geometry formula lock",
      "resolved_in": "Step 2A",
      "details": "CodeNode now carries export_count/building_height/footprint"
    }
  ]
}
```

## 5. Agent Workflow

### Before Modifying Code

1. Check if sidecar exists: `ls .taskmaster/docs/file-guides/{path}/{file}.integration.*`
2. Read sidecar to understand:
   - **Risks**: Known integration hazards
   - **Anchors**: Critical line references (API boundaries, formulas, state)
   - **Gaps**: Known missing functionality

### After Modifying Code

1. Update line numbers in `anchors` array
2. Add new anchors for any new critical lines
3. Mark resolved gaps as resolved
4. Update `total_lines` and `sha256` hash
5. Document what changed in markdown "Integration Use" section

### For Research

Use the **brief** endpoint for lightweight context:

```bash
curl -s "http://127.0.0.1:37888/v1/memory/brief?q=woven+maps+node+click&budget=2000"
```

### For Integration

Use the **graph** endpoint to understand relationships:

```bash
curl -s "http://127.0.0.1:37888/v1/memory/graph?q=connection+panel&file_limit=5"
```

## 6. Claude Auto-Memory

### Location

`~/.claude/projects/{project-hash}/memory/MEMORY.md`

### Purpose

Auto-loaded into system prompt for ALL sessions in this project. Keep **under 200 lines**.

### What to Save

- Stable architecture patterns (not session-specific state)
- Key file relationships and data flow
- Critical decisions and their rationale
- Known risks and constraints
- Project-specific conventions

### What NOT to Save

- Temporary debugging notes
- Session-specific task lists
- Transient error messages
- Work-in-progress implementation details

## 7. Quick Reference

### Start Memory Stack

```bash
bash .taskmaster/tools/memory-gateway/memory-stack.sh start
```

### Get File Hash

```bash
sha256sum IP/woven_maps.py | cut -d' ' -f1
```

### Count Lines

```bash
wc -l IP/woven_maps.py | awk '{print $1}'
```

### Query Memory Brief

```bash
curl -s "http://127.0.0.1:37888/v1/memory/brief?q=YOUR_QUERY&budget=2000&file_limit=8"
```

### Query Memory Graph

```bash
curl -s "http://127.0.0.1:37888/v1/memory/graph?q=YOUR_QUERY&file_limit=5&anchor_limit=3"
```

### Save Memory Observation

```bash
curl -s -X POST "http://127.0.0.1:37888/v1/memory/save" \
  -H "Content-Type: application/json" \
  -d '{"title":"YOUR_TITLE","text":"YOUR_TEXT"}'
```

### Update Sidecar After Modification

```bash
# Get new line count and hash
wc -l IP/your_file.py
sha256sum IP/your_file.py

# Edit the sidecar files
vim .taskmaster/docs/file-guides/IP/your_file.py.integration.md
vim .taskmaster/docs/file-guides/IP/your_file.py.integration.json
```

---

## 8. UI/CSS Runtime Architecture — Current State of the Art

### Canonical CSS Source

Orchestr8 uses a single active stylesheet source:

| Source | Location | Status | Purpose |
|--------|----------|--------|---------|
| **Static CSS File (Loaded at Runtime)** | `IP/styles/orchestr8.css` | ✅ Active | Canonical colors, typography, overrides, interaction hardening |
| **Inline ORCHESTR8_CSS f-string** | `IP/plugins/06_maestro.py` | ❌ Legacy/retired | Historical approach; not the canonical source now |

Active load path:

```python
# IP/plugins/06_maestro.py
css_injection = mo.Html(load_orchestr8_css())
```

### Canonical UI Entry + Runtime Discipline

1. Entry point: `orchestr8.py`
2. UI implementation: `IP/plugins/06_maestro.py`
3. Visualization: `IP/woven_maps.py`
4. Run one instance only:
   - preferred launcher: `scripts/run_orchestr8_single.sh`

### Implementation Order (Locked)

When building features, follow this order:

1. Visual contract first (colors, typography, spacing, emergence behavior)
2. Browser compatibility pass (CSS syntax/at-rules/selectors/properties)
3. Responsive behavior pass (desktop + mobile layout fit)
4. Interaction wiring pass (buttons/panels/events)
5. End-to-end test-drive pass (runtime + usability)

### Button and Panel Wiring Rules

1. For marimo buttons, use `on_click` (not `on_change`).
2. Prefer marimo UI elements over raw HTML `onclick` strings.
3. If HTML-only controls are unavoidable, add an explicit bridge contract.
4. Preserve right-panel mutual exclusion behavior (Calendar/Comms/Files).

### What We Can Do Reliably Right Now

1. Enforce canonical three-state palette in one place (`IP/styles/orchestr8.css`).
2. Apply source-level marimo frontend compatibility patches (not minified one-offs).
3. Run deterministic single-path startup and avoid duplicate-instance drift.
4. Capture decisions in both local ledger and shared memory gateway for continuity.

**Remember**: Sidecars are your integration contract. Keep them accurate, or downstream agents will break.
