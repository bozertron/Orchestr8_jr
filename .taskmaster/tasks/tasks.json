{
  "master": {
    "tasks": [
      {
        "id": 13,
        "title": "Refactor Gatekeeper Plugin for Louis Core Integration",
        "description": "Replace duplicate config management in 03_gatekeeper.py with LouisWarden and LouisConfig from louis_core.py",
        "details": "Import LouisWarden, LouisConfig from IP/louis_core.py. Remove all existing config code. Use project .louis-control/ path. Add 'Lock All Protected' button: iterate STATE_MANAGERS['selected'] and call warden.lock_file(path). Add 'Unlock All' button: iterate and call warden.unlock_file(path). Add per-file toggle checkboxes bound to STATE_MANAGERS['selected']. Use Python 3.12+ json module for state management. Ensure permissions: locked=0o444, unlocked=0o644.",
        "testStrategy": "Click 'Lock All', verify selected files have 0o444 permissions via os.stat(). Click 'Unlock All', verify 0o644. Toggle individual files and verify permission changes match selection state.",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Import LouisWarden and LouisConfig",
            "description": "Add imports for LouisWarden and LouisConfig from IP/louis_core.py at the top of 03_gatekeeper.py",
            "dependencies": [],
            "details": "Insert 'from IP.louis_core import LouisWarden, LouisConfig' after existing imports. Verify no import errors by running the file directly.",
            "status": "pending",
            "testStrategy": "Run 'python 03_gatekeeper.py' to confirm imports succeed without errors."
          },
          {
            "id": 2,
            "title": "Remove Existing Config Management Code",
            "description": "Delete all duplicate config management code in 03_gatekeeper.py and initialize LouisConfig with .louis-control/ path",
            "dependencies": [
              1
            ],
            "details": "Search for and remove all config-related variables/functions (config dicts, load/save functions). Replace with: config = LouisConfig('.louis-control/'). Ensure no references remain to old config.",
            "status": "pending",
            "testStrategy": "Use git diff to verify all config code removed. Run file to check no NameError on config usage."
          },
          {
            "id": 3,
            "title": "Implement Lock All Protected and Unlock All Buttons",
            "description": "Add two buttons that iterate over STATE_MANAGERS['selected'] and call warden.lock_file() or warden.unlock_file()",
            "dependencies": [
              1,
              2
            ],
            "details": "Create warden = LouisWarden(config). Add mo.ui.button('Lock All Protected', on_click=lambda: [warden.lock_file(path) for path in STATE_MANAGERS['selected']]). Add similar Unlock All button with warden.unlock_file(). Use Python 3.12+ json module for state serialization.",
            "status": "pending",
            "testStrategy": "Click buttons with selected files, verify os.stat(file).st_mode & 0o777 == 0o444 for lock, 0o644 for unlock."
          },
          {
            "id": 4,
            "title": "Add Per-File Toggle Checkboxes",
            "description": "Create checkboxes for each file in STATE_MANAGERS['selected'] bound to lock/unlock state",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "For each file in STATE_MANAGERS['selected'], create mo.ui.checkbox(label=path, value=is_locked(path), on_change=lambda checked, path: warden.lock_file(path) if checked else warden.unlock_file(path)). Update state management with json module.",
            "status": "pending",
            "testStrategy": "Toggle checkbox on/off, verify file permissions change immediately to 0o444/0o644 matching checkbox state."
          },
          {
            "id": 5,
            "title": "Finalize Permissions and State Management Integration",
            "description": "Ensure all lock/unlock operations set correct permissions and integrate with project state using Python 3.12+ json",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Verify lock_file sets 0o444, unlock_file sets 0o644 using os.chmod. Persist state to .louis-control/ using config.save_state() with json.dump (indent=2). Handle all edge cases like non-existent files.",
            "status": "pending",
            "testStrategy": "Full end-to-end: select files, toggle individual + bulk buttons, restart Marimo, verify state persists and permissions match UI state."
          }
        ]
      },
      {
        "id": 14,
        "title": "Implement JSON Table Rendering Utility",
        "description": "Create detect_and_render_output() function for smart output rendering in IP/plugins/",
        "details": "Create IP/plugins/output_renderer.py. Use Python 3.12+ json module: try json.loads(stdout_text) except JSONDecodeError: return mo.ui.text_area(stdout_text). For JSON array: mo.ui.table(data=json_data, sortable=True). For JSON object: mo.ui.json(json_data) or mo.ui.text_area(json.dumps(json_data, indent=2)). Integrate into 05_cli_bridge.py and future universal_bridge.py output pipeline. Handle large JSON with pagination if >1000 rows.",
        "testStrategy": "Test with JSON array: verify sortable mo.ui.table renders. Test JSON object: verify formatted display. Test plain text: verify mo.ui.text_area. Test invalid JSON: graceful fallback.",
        "priority": "medium",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create output_renderer.py module",
            "description": "Create the IP/plugins/output_renderer.py file with basic structure and imports for JSON handling and mo.ui components.",
            "dependencies": [],
            "details": "Include imports: import json, from json.decoder import JSONDecodeError, import mo. Add function signature def detect_and_render_output(stdout_text: str) -> None: pass. Ensure Python 3.12+ compatibility.",
            "status": "pending",
            "testStrategy": "Verify file created at IP/plugins/output_renderer.py with correct imports and function skeleton."
          },
          {
            "id": 2,
            "title": "Implement JSON detection and basic rendering logic",
            "description": "Add core logic to detect JSON in stdout_text and render appropriately: fallback to text_area for invalid JSON.",
            "dependencies": [
              1
            ],
            "details": "Implement try: json_data = json.loads(stdout_text) except JSONDecodeError: return mo.ui.text_area(stdout_text). For JSON array (isinstance(json_data, list)): mo.ui.table(data=json_data, sortable=True). For JSON object (dict): mo.ui.json(json_data) or mo.ui.text_area(json.dumps(json_data, indent=2)).",
            "status": "pending",
            "testStrategy": "Test invalid JSON falls back to text_area. Test valid JSON array renders sortable table. Test JSON object renders formatted JSON."
          },
          {
            "id": 3,
            "title": "Add large JSON pagination handling",
            "description": "Implement pagination logic for JSON arrays exceeding 1000 rows to handle large datasets efficiently.",
            "dependencies": [
              2
            ],
            "details": "After detecting list and len(json_data) > 1000, implement pagination using mo.ui components (e.g., paginated table or sliced data with navigation). Add configurable threshold (default 1000). Preserve sortable=True where possible.",
            "status": "pending",
            "testStrategy": "Test JSON array with 1001+ rows triggers pagination. Verify data slicing works correctly and navigation functions."
          },
          {
            "id": 4,
            "title": "Integrate into 05_cli_bridge.py output pipeline",
            "description": "Modify 05_cli_bridge.py to use detect_and_render_output() in its stdout processing pipeline.",
            "dependencies": [
              2
            ],
            "details": "Locate stdout/output rendering section in 05_cli_bridge.py. Replace existing output display with: from IP.plugins.output_renderer import detect_and_render_output; detect_and_render_output(stdout_text). Ensure seamless integration without breaking existing flow.",
            "status": "pending",
            "testStrategy": "Run 05_cli_bridge.py with JSON output: verify smart rendering. Test plain text: verify text_area fallback. Test large JSON: verify pagination."
          },
          {
            "id": 5,
            "title": "Add comprehensive tests and documentation",
            "description": "Create test cases and documentation for the complete JSON rendering utility including edge cases.",
            "dependencies": [
              3,
              4
            ],
            "details": "Add docstring to detect_and_render_output() explaining parameters, return types, rendering logic, and pagination. Create test suite covering: valid JSON array (sortable table), JSON object (formatted), invalid JSON (fallback), large array (>1000 rows pagination), empty JSON []. Document integration points for universal_bridge.py.",
            "status": "pending",
            "testStrategy": "Run full test suite: verify all rendering paths work. Test edge cases: empty arrays/objects, malformed JSON, extremely large datasets. Verify 05_cli_bridge.py integration doesn't break existing functionality."
          }
        ]
      },
      {
        "id": 15,
        "title": "Create Registry Directory Structure",
        "description": "Setup frontend/tools/registry/ directory with .gitkeep",
        "details": "mkdir -p frontend/tools/registry/. Touch frontend/tools/registry/.gitkeep. Ensure .gitkeep prevents empty directory deletion in git. Verify structure: frontend/tools/registry/, parsers/, scaffold-cli.ts. Use Python pathlib for directory creation in setup script if needed.",
        "testStrategy": "ls frontend/tools/registry/ should show .gitkeep. Git status should track empty directory.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Create Scaffold Manifest 01_scaffold.json",
        "description": "Generate first registry manifest for TypeScript Scaffold parsers",
        "details": "Create frontend/tools/registry/01_scaffold.json exactly as specified: {name:\"Scaffold Parsers (TS)\", description:\"TypeScript AST analysis tools powered by Commander.js\", icon:\"TS\", base_command:[\"npx\",\"tsx\",\"frontend/tools/scaffold-cli.ts\"], discovery:{enabled:true, command:\"list-plugins\"}}. Validate with python -m json.tool < file.",
        "testStrategy": "python -m json.tool frontend/tools/registry/01_scaffold.json should parse without errors.",
        "priority": "high",
        "dependencies": [
          15
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Add Silent JSON Mode to scaffold-cli.ts",
        "description": "Modify scaffold-cli.ts to output clean JSON in machine mode without console logs",
        "details": "Use Node.js 22+ with tsx. Add at list-plugins command start: const isMachineMode = !process.stdout.isTTY || process.argv.includes('--json'); if(!isMachineMode) console.log('Listing available plugins...');. Output: console.log(JSON.stringify(plugins, null, isMachineMode ? 0 : 2));. No emoji prefixes, no extra messages. Test: npx tsx scaffold-cli.ts list-plugins --json | python -m json.tool.",
        "testStrategy": "npx tsx scaffold-cli.ts list-plugins --json | python -m json.tool parses cleanly. Non-TTY mode outputs only JSON blob.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Define machine mode detection logic",
            "description": "Add code to detect if running in machine-readable mode based on TTY or --json flag",
            "dependencies": [],
            "details": "Insert at list-plugins command start: const isMachineMode = !process.stdout.isTTY || process.argv.includes('--json');. This detects non-interactive TTY or explicit --json flag for JSON output.",
            "status": "pending",
            "testStrategy": "Verify isMachineMode=true when running with --json flag and false in interactive TTY."
          },
          {
            "id": 2,
            "title": "Add conditional human-readable header",
            "description": "Print 'Listing available plugins...' message only when not in machine mode",
            "dependencies": [
              1
            ],
            "details": "After machine mode detection, add: if(!isMachineMode) console.log('Listing available plugins...');. Ensures clean JSON output in machine mode without extra messages.",
            "status": "pending",
            "testStrategy": "Check header appears in TTY mode without --json, absent with --json."
          },
          {
            "id": 3,
            "title": "Modify plugins output to conditional JSON formatting",
            "description": "Replace existing plugins console.log with machine-aware JSON.stringify formatting",
            "dependencies": [
              1
            ],
            "details": "Change output to: console.log(JSON.stringify(plugins, null, isMachineMode ? 0 : 2));. Uses compact JSON (no indent) in machine mode, pretty-printed (2 spaces) in human mode.",
            "status": "pending",
            "testStrategy": "Verify compact JSON with --json, pretty JSON without flag."
          },
          {
            "id": 4,
            "title": "Remove emoji prefixes and extra console messages",
            "description": "Audit and remove all emoji prefixes and extraneous console.log statements from list-plugins",
            "dependencies": [
              2,
              3
            ],
            "details": "Scan list-plugins command for emoji prefixes (ðŸš€, âœ…, etc.) and non-essential messages. Ensure only the conditional header and final JSON output remain. No extra messages in machine mode.",
            "status": "pending",
            "testStrategy": "Confirm no emojis or extra text in --json output."
          },
          {
            "id": 5,
            "title": "Test silent JSON mode end-to-end",
            "description": "Validate clean JSON output parses correctly in machine mode using provided test command",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Run: npx tsx scaffold-cli.ts list-plugins --json | python -m json.tool. Verify output is valid JSON with no extra text. Test non-TTY piping and interactive modes separately.",
            "status": "pending",
            "testStrategy": "JSON parses cleanly via python -m json.tool. Non-TTY outputs only JSON blob without headers."
          }
        ]
      },
      {
        "id": 18,
        "title": "Develop Universal Bridge Plugin 05_universal_bridge.py",
        "description": "Create core Universal Bridge that dynamically scans registry and generates UI",
        "details": "PLUGIN_ORDER=5, PLUGIN_NAME='Universal Bridge'. Scan frontend/tools/registry/*.json (skip .template). Validate REQUIRED_FIELDS=['name','base_command'], OPTIONAL_FIELDS=['description','icon','discovery','static_commands']. For each valid manifest: mo.ui.accordion() with manifest.name. If discovery.enabled: subprocess.run(manifest.base_command + [discovery.command], timeout=30, capture_output=True), parse JSON with json.loads(), generate mo.ui.button() per item. If static_commands: generate buttons from array. Execution: subprocess.run(full_command, timeout=30, capture_output=True), then detect_and_render_output(stdout). Use Python 3.12+ pathlib.glob('**/*.json'), shutil.which() for command validation.",
        "testStrategy": "Create test manifest, restart Marimo, verify dynamic accordion appears, execute discovery and static commands, verify JSON table/text rendering.",
        "priority": "high",
        "dependencies": [
          14,
          16,
          17
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Plugin File and Define Constants",
            "description": "Initialize 05_universal_bridge.py with PLUGIN_ORDER=5 and PLUGIN_NAME='Universal Bridge'.",
            "dependencies": [],
            "details": "Create the Python file in the plugins directory. Define constants at module top: PLUGIN_ORDER=5, PLUGIN_NAME='Universal Bridge'. Add basic imports: pathlib, json, subprocess, shutil, mo.ui.",
            "status": "pending",
            "testStrategy": "Verify file exists and constants print correctly when imported."
          },
          {
            "id": 2,
            "title": "Implement Registry Scanning and Manifest Validation",
            "description": "Scan frontend/tools/registry/*.json files, skip .template files, validate REQUIRED_FIELDS and OPTIONAL_FIELDS.",
            "dependencies": [
              1
            ],
            "details": "Use pathlib.glob('frontend/tools/registry/**/*.json') excluding paths with '.template'. Load JSON, check for required keys ['name','base_command'], optional ['description','icon','discovery','static_commands']. Collect valid manifests in list.",
            "status": "pending",
            "testStrategy": "Create test JSON files, assert valid manifests list has correct entries, invalid ones skipped."
          },
          {
            "id": 3,
            "title": "Generate UI Accordions for Valid Manifests",
            "description": "For each valid manifest, create mo.ui.accordion() using manifest.name as title.",
            "dependencies": [
              2
            ],
            "details": "Loop through valid manifests. Use mo.ui.accordion(manifest.get('name', 'Unknown'), contents=[]) initially. Store accordion references for later population. Render accordions in main UI.",
            "status": "pending",
            "testStrategy": "Restart Marimo, verify accordions appear with correct names from manifests."
          },
          {
            "id": 4,
            "title": "Implement Discovery and Static Commands Button Generation",
            "description": "For manifests with discovery.enabled, run discovery command and generate buttons. Add static_commands buttons.",
            "dependencies": [
              3
            ],
            "details": "If 'discovery' in manifest and discovery.get('enabled'): run subprocess.run([base_command, discovery.command], timeout=30, capture_output=True), parse json.loads(stdout). Create mo.ui.button() per item. If 'static_commands': generate buttons from array.",
            "status": "pending",
            "testStrategy": "Verify buttons appear in accordions after discovery/static commands processed."
          },
          {
            "id": 5,
            "title": "Implement Command Execution and Output Rendering",
            "description": "Handle button clicks: run full_command via subprocess, use detect_and_render_output(stdout). Validate commands with shutil.which().",
            "dependencies": [
              4
            ],
            "details": "On button click: validate shutil.which(base_command[0]), run subprocess.run(full_command, timeout=30, capture_output=True). Call detect_and_render_output(stdout) for JSON table/text rendering.",
            "status": "pending",
            "testStrategy": "Click buttons, verify commands execute, output renders as JSON table or text correctly."
          }
        ]
      },
      {
        "id": 19,
        "title": "Retire Old CLI Bridge Plugin",
        "description": "Deprecate 05_cli_bridge.py after Universal Bridge verification",
        "details": "Rename IP/plugins/05_cli_bridge.py to 05_cli_bridge.py.deprecated. Verify no duplicate tabs in Marimo UI. Preserve git history. Update any references if needed.",
        "testStrategy": "Restart marimo edit IP/orchestr8_app.py, verify only Universal Bridge tab appears, no CLI Bridge tab.",
        "priority": "low",
        "dependencies": [
          18
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Create Daco Rust Manifest Template",
        "description": "Generate 02_daco.json.template for future Rust integration",
        "details": "Create frontend/tools/registry/02_daco.json.template exactly as specified with static_commands for 'Overview' and 'Routes'. Use .template extension to prevent loading by Universal Bridge. Validate JSON syntax.",
        "testStrategy": "python -m json.tool 02_daco.json.template succeeds. Restart Marimo, verify Universal Bridge ignores .template files.",
        "priority": "low",
        "dependencies": [
          15
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "End-to-End Universal Bridge Integration Test",
        "description": "Complete E2E test of Scaffold Parsers integration",
        "details": "marimo edit IP/orchestr8_app.py â†’ Universal Bridge tab â†’ Verify 'Scaffold Parsers (TS)' accordion â†’ Expand â†’ Verify discovered plugins as buttons â†’ Execute 'overview' parser â†’ Verify JSON table rendering. Document failures in test log.",
        "testStrategy": "Manual walkthrough: accordion appears, plugins discovered, execution succeeds, output renders correctly.",
        "priority": "high",
        "dependencies": [
          18
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Multi-Manifest and Dynamic UI Test",
        "description": "Verify multiple manifests and dynamic UI updates",
        "details": "Create 99_test.json with static_commands. Restart Marimo: verify both Scaffold + Test accordions. Execute test command. Remove 99_test.json, restart: verify only Scaffold remains. Test hot reload capability.",
        "testStrategy": "Add/remove manifests, verify UI updates on Marimo restart. Multiple accordions render correctly without conflicts.",
        "priority": "medium",
        "dependencies": [
          21
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2026-01-26T05:47:32.622Z",
      "updated": "2026-01-26T05:47:32.622Z",
      "description": "Tasks for master context"
    }
  }
}